import Jimp from 'jimp';
import EventEmitter from 'events';
import SVGParser, { flip, rotate, scale, sortShapes, translate } from '../../../shared/lib/SVGParser';
import Normalizer from './Normalizer';
import { svgToSegments } from './SVGFill';
import { parseDxf, dxfToSvg, updateDxfBoundingBox } from '../../../shared/lib/DXFParser/Parser';
import XToBToolPath from '../ToolPath/XToBToolPath';

function pointEqual(p1, p2) {
    return p1[0] === p2[0] && p1[1] === p2[1];
}

class LaserToolPathGenerator extends EventEmitter {
    constructor(modelInfo) {
        super();
        const { isRotate, diameter } = modelInfo.materials;
        this.toolPath = new XToBToolPath({ isRotate, diameter });
        this.modelInfo = modelInfo;
    }

    getGcodeHeader() {
        const date = new Date();
        this.toolPath.setComment('; G-code for laser engraving');
        this.toolPath.setComment('; Generated by Snapmaker Luban');
        this.toolPath.setComment(`; ${date.toDateString()} ${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}`);
        this.toolPath.setN();
    }

    async generateToolPathObj(modelInfo, modelPath) {
        const { headType, mode, gcodeConfig, sourceType, transformation, materials } = modelInfo;
        const { isRotate, diameter } = materials;
        const { positionX, positionY, positionZ } = transformation;

        const { movementMode } = gcodeConfig;

        const toolPath = this.toolPath;

        this.getGcodeHeader();

        toolPath.setCommand({ G: 90 });
        toolPath.setCommand({ G: 21 });

        toolPath.setComment('; G-code START <<<');
        toolPath.setCommand({ M: 106, P: 0, S: 255 });

        if (mode === 'bw' || mode === 'halftone' || (mode === 'greyscale' && movementMode === 'greyscale-line')) {
            await this.generateGcodeBW(modelInfo, modelPath);
        } else if (mode === 'greyscale') {
            await this.generateGcodeGreyscale(modelInfo, modelPath);
        } else if (mode === 'vector' && sourceType === 'dxf') {
            await this.generateGcodeDxf(modelInfo, modelPath);
        } else if (mode === 'vector' || mode === 'trace') {
            await this.generateGcodeVector(modelInfo, modelPath);
        } else if (sourceType === 'svg' && mode === 'text') {
            await this.generateGcodeVector(modelInfo, modelPath);
        } else {
            return Promise.reject(new Error(`Unsupported process mode: ${mode}`));
        }

        toolPath.setCommand({ M: 107, P: 0 });
        toolPath.setComment('; G-code END <<<');

        const boundingBox = toolPath.boundingBox;


        if (isRotate) {
            boundingBox.max.b += toolPath.toB(positionX);
            boundingBox.min.b += toolPath.toB(positionX);
        } else {
            boundingBox.max.x += positionX;
            boundingBox.min.x += positionX;
        }
        boundingBox.max.y += positionY;
        boundingBox.min.y += positionY;

        return {
            headType: headType,
            mode: mode,
            movementMode: (headType === 'laser' && mode === 'greyscale') ? gcodeConfig.movementMode : '',
            data: toolPath.commands,
            estimatedTime: toolPath.estimatedTime * 1.4,
            positionX: positionX,
            positionY: positionY,
            positionZ: positionZ,
            rotationB: isRotate ? toolPath.toB(positionX) : 0,
            boundingBox: boundingBox,
            isRotate: isRotate,
            diameter: diameter
        };
    }

    async generateGcodeGreyscale(modelInfo, modelPath) {
        const { gcodeConfigPlaceholder, config, gcodeConfig } = modelInfo;
        const { fixedPowerEnabled, fixedPower, workSpeed } = gcodeConfig;
        const { dwellTime } = gcodeConfigPlaceholder;
        const { bwThreshold } = config;

        const img = await Jimp.read(modelPath);
        img.mirror(false, true);

        const width = img.bitmap.width;
        const height = img.bitmap.height;

        const normalizer = new Normalizer('Center', 0, width, 0, height, {
            x: 1 / gcodeConfig.density,
            y: 1 / gcodeConfig.density
        });

        let progress = 0;

        let firstTurnOn = true;
        function turnOnLaser() {
            if (firstTurnOn && fixedPowerEnabled) {
                firstTurnOn = false;
                const powerStrength = Math.floor(fixedPower * 255 / 100);
                return { P: fixedPower, S: powerStrength };
            }
            return {};
        }

        const toolPath = this.toolPath;
        toolPath.setMove1F(workSpeed);

        for (let i = 0; i < width; ++i) {
            const isReverse = (i % 2 === 0);
            await this.modelInfo.taskAsyncFor(isReverse ? height : 0, isReverse ? 0 : height - 1, isReverse ? -1 : 1, (j) => {
                const idx = j * width * 4 + i * 4;
                if (img.bitmap.data[idx] < bwThreshold) {
                    toolPath.move1XY(normalizer.x(i), normalizer.y(j));
                    toolPath.spindleOn(turnOnLaser());
                    toolPath.setCommand({ G: 4, P: dwellTime });
                    toolPath.spindleOff();
                }
            });
            const p = i / width;
            if (p - progress > 0.05) {
                progress = p;
                this.emit('progress', progress);
            }
        }
        toolPath.move0XY(0, 0);

        return toolPath;
    }

    async generateGcodeBW(modelInfo, modelPath) {
        const { config, gcodeConfig } = modelInfo;
        const { fixedPowerEnabled, fixedPower, workSpeed, jogSpeed } = gcodeConfig;
        const { bwThreshold } = config;

        function bitEqual(a, b) {
            return (a <= bwThreshold && b <= bwThreshold) || (a > bwThreshold && b > bwThreshold);
        }

        function extractSegment(data, start, box, direction, sign) {
            let len = 1;

            function idx(pos) {
                return pos.x * 4 + pos.y * box.width * 4;
            }

            for (; ;) {
                const cur = {
                    x: start.x + direction.x * len * sign,
                    y: start.y + direction.y * len * sign
                };
                if (!bitEqual(data[idx(cur)], data[idx(start)])
                    || cur.x < 0 || cur.x >= box.width
                    || cur.y < 0 || cur.y >= box.height) {
                    break;
                }
                len += 1;
            }
            return len;
        }

        const toolPath = this.toolPath;

        let firstTurnOn = true;
        function turnOnLaser() {
            if (firstTurnOn && fixedPowerEnabled) {
                firstTurnOn = false;
                const powerStrength = Math.floor(fixedPower * 255 / 100);
                return { P: fixedPower, S: powerStrength };
            }
            return {};
        }

        function genMovement(normalizer, start, end) {
            toolPath.move0XY(normalizer.x(start.x), normalizer.y(start.y));
            toolPath.spindleOn(turnOnLaser());
            toolPath.move1XY(normalizer.x(end.x), normalizer.y(end.y));
            toolPath.spindleOff();
        }


        const img = await Jimp.read(modelPath);
        img.mirror(false, true);

        const width = img.bitmap.width;
        const height = img.bitmap.height;

        const normalizer = new Normalizer('Center', 0, width, 0, height, {
            x: 1 / gcodeConfig.density,
            y: 1 / gcodeConfig.density
        });

        let progress = 0;

        toolPath.setMove0F(jogSpeed);
        toolPath.setMove1F(workSpeed);

        if (!gcodeConfig.direction || gcodeConfig.direction === 'Horizontal') {
            const direction = {
                x: 1,
                y: 0
            };
            for (let j = 0; j < height; j++) {
                let len = 0;
                const isReverse = (j % 2 !== 0);
                const sign = isReverse ? -1 : 1;
                for (let i = (isReverse ? width - 1 : 0); isReverse ? i >= 0 : i < width; i += len * sign) {
                    const idx = i * 4 + j * width * 4;
                    if (img.bitmap.data[idx] <= bwThreshold) {
                        const start = {
                            x: i,
                            y: j
                        };
                        len = extractSegment(img.bitmap.data, start, img.bitmap, direction, sign);
                        const end = {
                            x: start.x + direction.x * len * sign,
                            y: start.y + direction.y * len * sign
                        };
                        genMovement(normalizer, start, end);
                    } else {
                        len = 1;
                    }
                }
                const p = j / height;
                if (p - progress > 0.05) {
                    progress = p;
                    this.emit('progress', progress);
                }
            }
        } else if (gcodeConfig.direction === 'Vertical') {
            const direction = {
                x: 0,
                y: 1
            };
            for (let i = 0; i < width; ++i) {
                let len = 0;
                const isReverse = (i % 2 !== 0);
                const sign = isReverse ? -1 : 1;
                for (let j = (isReverse ? height - 1 : 0); isReverse ? j >= 0 : j < height; j += len * sign) {
                    const idx = i * 4 + j * width * 4;
                    if (img.bitmap.data[idx] <= bwThreshold) {
                        const start = {
                            x: i,
                            y: j
                        };
                        len = extractSegment(img.bitmap.data, start, img.bitmap, direction, sign);
                        const end = {
                            x: start.x + direction.x * len * sign,
                            y: start.y + direction.y * len * sign
                        };
                        genMovement(normalizer, start, end);
                    } else {
                        len = 1;
                    }
                }
                const p = i / width;
                if (p - progress > 0.05) {
                    progress = p;
                    this.emit('progress', progress);
                }
            }
        } else if (gcodeConfig.direction === 'Diagonal') {
            const direction = {
                x: 1,
                y: -1
            };
            for (let k = 0; k < width + height - 1; k++) {
                let len = 0;
                const isReverse = (k % 2 !== 0);
                const sign = isReverse ? -1 : 1;
                for (let i = (isReverse ? width - 1 : 0); isReverse ? i >= 0 : i < width; i += len * sign) {
                    const j = k - i;
                    if (j < 0 || j > height) {
                        len = 1; // FIXME: optimize
                    } else {
                        const idx = i * 4 + j * width * 4;
                        if (img.bitmap.data[idx] <= bwThreshold) {
                            const start = {
                                x: i,
                                y: j
                            };
                            len = extractSegment(img.bitmap.data, start, img.bitmap, direction, sign);
                            const end = {
                                x: start.x + direction.x * len * sign,
                                y: start.y + direction.y * len * sign
                            };
                            genMovement(normalizer, start, end);
                        } else {
                            len = 1;
                        }
                    }
                }
                const p = k / (width + height);
                if (p - progress > 0.05) {
                    progress = p;
                    this.emit('progress', progress);
                }
            }
        } else if (gcodeConfig.direction === 'Diagonal2') {
            const direction = {
                x: 1,
                y: 1
            };
            for (let k = -height; k <= width; k++) {
                const isReverse = (k % 2 !== 0);
                const sign = isReverse ? -1 : 1;
                let len = 0;
                for (let i = (isReverse ? width - 1 : 0); isReverse ? i >= 0 : i < width; i += len * sign) {
                    const j = i - k;
                    if (j < 0 || j > height) {
                        len = 1;
                    } else {
                        const idx = i * 4 + j * width * 4;
                        if (img.bitmap.data[idx] <= bwThreshold) {
                            const start = {
                                x: i,
                                y: j
                            };
                            len = extractSegment(img.bitmap.data, start, img.bitmap, direction, sign);
                            const end = {
                                x: start.x + direction.x * len * sign,
                                y: start.y + direction.y * len * sign
                            };
                            genMovement(normalizer, start, end);
                        } else {
                            len = 1;
                        }
                    }
                }
                const p = k / (width + height);
                if (p - progress > 0.05) {
                    progress = p;
                    this.emit('progress', progress);
                }
            }
        }
        toolPath.move0XY(0, 0);

        return toolPath;
    }

    async generateGcodeDxf(modelInfo, modelPath) {
        let { svg } = await parseDxf(modelPath);
        svg = dxfToSvg(svg);
        updateDxfBoundingBox(svg);

        return this._generateGcodeSvg(svg, modelInfo);
    }

    async generateGcodeVector(modelInfo, modelPath) {
        const svgParser = new SVGParser();

        const svg = await svgParser.parseFile(modelPath);
        flip(svg, 1);

        return this._generateGcodeSvg(svg, modelInfo);
    }

    _generateGcodeSvg(svg, modelInfo) {
        const { transformation, gcodeConfig } = modelInfo;
        const { fillEnabled, fillDensity, optimizePath } = gcodeConfig;
        const { fixedPowerEnabled, fixedPower, workSpeed, jogSpeed } = gcodeConfig;
        const originWidth = svg.width;
        const originHeight = svg.height;
        const targetWidth = transformation.width;
        const targetHeight = transformation.height;

        // rotation: degree and counter-clockwise
        const rotationZ = transformation.rotationZ;
        // const flipFlag = transformation.flip;

        // flip(svg, flipFlag);
        scale(svg, {
            x: (transformation.scaleX < 0 ? -1 : 1) * targetWidth / originWidth,
            y: (transformation.scaleY < 0 ? -1 : 1) * targetHeight / originHeight
        });

        // For performance reason, we only optimize SVG with number of shapes less than 2000
        if (optimizePath && svg.shapes.length < 2000) {
            sortShapes(svg);
        }
        rotate(svg, rotationZ); // rotate: unit is radians and counter-clockwise
        translate(svg, -svg.viewBox[0], -svg.viewBox[1]);

        const normalizer = new Normalizer(
            'Center',
            svg.viewBox[0],
            svg.viewBox[0] + svg.viewBox[2],
            svg.viewBox[1],
            svg.viewBox[1] + svg.viewBox[3],
            {
                x: 1,
                y: 1
            }
        );


        const segments = svgToSegments(svg, {
            width: svg.viewBox[2],
            height: svg.viewBox[3],
            fillEnabled: fillEnabled,
            fillDensity: fillDensity
        });

        let firstTurnOn = true;
        function turnOnLaser() {
            if (firstTurnOn && fixedPowerEnabled) {
                firstTurnOn = false;
                const powerStrength = Math.floor(fixedPower * 255 / 100);
                return { P: fixedPower, S: powerStrength };
            }
            return {};
        }

        // second pass generate gcode
        let progress = 0;

        const toolPath = this.toolPath;

        toolPath.setMove0F(jogSpeed);
        toolPath.setMove1F(workSpeed);

        let current = null;
        for (const segment of segments) {
            // G0 move to start
            if (!current || current && !(pointEqual(current, segment.start))) {
                if (current) {
                    toolPath.spindleOff();
                }

                // Move to start point
                toolPath.move0XY(normalizer.x(segment.start[0]), normalizer.y(segment.start[1]));
                toolPath.spindleOn(turnOnLaser());
            }

            // G0 move to end
            toolPath.move1XY(normalizer.x(segment.end[0]), normalizer.y(segment.end[1]));

            current = segment.end;

            progress += 1;
        }
        if (segments.length !== 0) {
            progress /= segments.length;
        }
        this.emit('progress', progress);
        // turn off
        if (current) {
            toolPath.spindleOff();
        }

        // move to work zero
        toolPath.move0XY(0, 0);
        return toolPath;
    }
}

export default LaserToolPathGenerator;
