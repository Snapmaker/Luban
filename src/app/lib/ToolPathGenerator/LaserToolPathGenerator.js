import Jimp from 'jimp';
import SVGParser from '../SVGParser';


class Normalizer {
    constructor(anchor, minX, maxX, minY, maxY, scale) {
        this.anchor = anchor;
        this.minX = minX;
        this.maxX = maxX;
        this.minY = minY;
        this.maxY = maxY;
        this.scale = scale;
    }

    x(x) {
        if (this.anchor.endsWith('Left')) {
            x -= this.minX;
        } else if (this.anchor.endsWith('Right')) {
            x -= this.maxX;
        } else {
            x -= (this.minX + this.maxX) * 0.5;
        }
        return Number((x * this.scale.x).toFixed(4));
    }

    y(y) {
        if (this.anchor.startsWith('Bottom')) {
            y -= this.minY;
        } else if (this.anchor.startsWith('Top')) {
            y -= this.maxY;
        } else {
            y -= (this.minY + this.maxY) * 0.5;
        }
        return Number((y * this.scale.y).toFixed(4));
    }
}

class LaserToolPathGenerator {
    constructor(options) {
        this.options = options;
    }

    getGcodeHeader() {
        return [
            '; Laser text engrave G-code',
            '; Generated by Snapmakerjs',
            `; ${new Date().toLocaleDateString()}`
        ].join('\n') + '\n';
    }

    generateGcode() {
        const { mode } = this.options;
        if (mode === 'greyscale') {
            return this.generateGcodeGreyscale();
        } else if (mode === 'bw') {
            return this.generateGcodeBW();
        } else if (mode === 'vector') {
            return this.generateGcodeVector();
        } else if (mode === 'text') {
            return this.generateGcodeText();
        } else {
            return Promise.reject(new Error('Unsupported mode'));
        }
    }

    generateGcodeGreyscale() {
        const { source, target, greyscaleMode } = this.options;

        return Jimp
            .read(source.processed)
            .then(img => img.mirror(false, true))
            .then(img => {
                const width = img.bitmap.width;
                const height = img.bitmap.height;

                const normalizer = new Normalizer(target.anchor, 0, width, 0, height, {
                    x: 1 / greyscaleMode.density,
                    y: 1 / greyscaleMode.density
                });

                // const xOffset = alignment === 'center' ? -width / density * 0.5 : 0;
                // const yOffset = alignment === 'center' ? -height / density * 0.5 : 0;

                let content = this.getGcodeHeader();
                content += 'G90\n';
                content += 'G21\n';
                content += `G1 F${target.workSpeed}\n`;

                for (let i = 0; i < width; ++i) {
                    const isReverse = (i % 2 === 0);
                    for (let j = (isReverse ? height : 0); isReverse ? j >= 0 : j < height; isReverse ? j-- : j++) {
                        const idx = j * width * 4 + i * 4;
                        if (img.bitmap.data[idx] < 128) {
                            content += `G1 X${normalizer.x(i)} Y${normalizer.y(j)}\n`;
                            content += 'M03\n';
                            content += `G4 P${target.dwellTime}\n`;
                            content += 'M05\n';
                        }
                    }
                }
                content += 'G0 X0 Y0';

                return content;
            });
    }

    generateGcodeBW() {
        const { source, target, bwMode } = this.options;

        function extractSegment(data, start, box, direction, sign) {
            let len = 1;
            function idx(pos) {
                return pos.x * 4 + pos.y * box.width * 4;
            }
            for (;;) {
                let cur = {
                    x: start.x + direction.x * len * sign,
                    y: start.y + direction.y * len * sign
                };
                if (data[idx(cur)] !== data[idx(start)]
                || cur.x < 0 || cur.x >= box.width
                || cur.y < 0 || cur.y >= box.height) {
                    break;
                }
                len += 1;
            }
            return len;
        }

        function genMovement(normalizer, start, end) {
            return [
                `G0 X${normalizer.x(start.x)} Y${normalizer.y(start.y)}`,
                'M3',
                `G1 X${normalizer.x(end.x)} Y${normalizer.y(end.y)}`,
                'M5'
            ].join('\n') + '\n';
        }

        return Jimp
            .read(source.processed)
            .then(img => img.mirror(false, true))
            .then(img => {
                const width = img.bitmap.width;
                const height = img.bitmap.height;

                const normalizer = new Normalizer(target.anchor, 0, width, 0, height, {
                    x: 1 / bwMode.density,
                    y: 1 / bwMode.density
                });

                let content = '';

                content += 'G90\n';
                content += 'G21\n';
                content += `G0 F${target.jogSpeed}\n`;
                content += `G1 F${target.workSpeed}\n`;

                if (bwMode.direction === 'Horizontal') {
                    const direction = { x: 1, y: 0 };
                    for (let j = 0; j < height; j++) {
                        let len = 0;
                        const isReverse = (j % 2 !== 0);
                        const sign = isReverse ? -1 : 1;
                        for (let i = (isReverse ? width - 1 : 0); isReverse ? i >= 0 : i < width; i += len * sign) {
                            const idx = i * 4 + j * width * 4;
                            if (img.bitmap.data[idx] <= 128) {
                                const start = {
                                    x: i,
                                    y: j
                                };
                                len = extractSegment(img.bitmap.data, start, img.bitmap, direction, sign);
                                const end = {
                                    x: start.x + direction.x * len * sign,
                                    y: start.y + direction.y * len * sign
                                };
                                content += genMovement(normalizer, start, end);
                            } else {
                                len = 1;
                            }
                        }
                    }
                } else if (bwMode.direction === 'Vertical') {
                    let direction = { x: 0, y: 1 };

                    for (let i = 0; i < width; ++i) {
                        let len = 0;
                        const isReverse = (i % 2 !== 0);
                        const sign = isReverse ? -1 : 1;
                        for (let j = (isReverse ? height - 1 : 0); isReverse ? j >= 0 : j < height; j += len * sign) {
                            const idx = i * 4 + j * width * 4;
                            if (img.bitmap.data[idx] <= 128) {
                                const start = {
                                    x: i,
                                    y: j
                                };
                                len = extractSegment(img.bitmap.data, start, img.bitmap, direction, sign);
                                const end = {
                                    x: start.x + direction.x * len * sign,
                                    y: start.y + direction.y * len * sign
                                };
                                content += genMovement(normalizer, start, end);
                            } else {
                                len = 1;
                            }
                        }
                    }
                } else if (bwMode.direction === 'Diagonal') {
                    const direction = { x: 1, y: -1 };

                    for (let k = 0; k < width + height - 1; k++) {
                        let len = 0;
                        const isReverse = (k % 2 !== 0);
                        const sign = isReverse ? -1 : 1;
                        for (let i = (isReverse ? width - 1 : 0); isReverse ? i >= 0 : i < width; i += len * sign) {
                            const j = k - i;
                            if (j < 0 || j > height) {
                                len = 1; // FIXME: optimize
                            } else {
                                const idx = i * 4 + j * width * 4;
                                if (img.bitmap.data[idx] <= 128) {
                                    const start = {
                                        x: i,
                                        y: j
                                    };
                                    len = extractSegment(img.bitmap.data, start, img.bitmap, direction, sign);
                                    const end = {
                                        x: start.x + direction.x * len * sign,
                                        y: start.y + direction.y * len * sign
                                    };
                                    content += genMovement(normalizer, start, end);
                                } else {
                                    len = 1;
                                }
                            }
                        }
                    }
                } else if (bwMode.direction === 'Diagonal2') {
                    const direction = { x: 1, y: 1 };

                    for (let k = -height; k <= width; k++) {
                        const isReverse = (k % 2 !== 0);
                        const sign = isReverse ? -1 : 1;
                        let len = 0;
                        for (let i = (isReverse ? width - 1 : 0); isReverse ? i >= 0 : i < width; i += len * sign) {
                            const j = i - k;
                            if (j < 0 || j > height) {
                                len = 1;
                            } else {
                                const idx = i * 4 + j * width * 4;
                                if (img.bitmap.data[idx] <= 128) {
                                    let start = {
                                        x: i,
                                        y: j
                                    };
                                    len = extractSegment(img.bitmap.data, start, img.bitmap, direction, sign);
                                    const end = {
                                        x: start.x + direction.x * len * sign,
                                        y: start.y + direction.y * len * sign
                                    };
                                    content += genMovement(normalizer, start, end);
                                } else {
                                    len = 1;
                                }
                            }
                        }
                    }
                }
                content += 'G0 X0 Y0\n';
                return content;
            });
    }

    async generateGcodeVector() {
        function dist2(a, b) {
            return Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2);
        }

        function sortBySeekTime(shapes) {
            const newShapes = [];

            const usedSet = new Set();
            let from = [0, 0];
            for (let loop = 0; loop < shapes.length; loop++) {
                let minDist = Infinity;
                let idx = -1;
                let rev = false;

                for (let i = 0; i < shapes.length; ++i) {
                    const shape = shapes[i];
                    if (usedSet.has(i)) {
                        continue;
                    }

                    for (let path of shape.paths) {
                        let tmpDist = dist2(path.points[0], from);
                        if (tmpDist < minDist) {
                            minDist = tmpDist;
                            rev = false;
                            idx = i;
                        }

                        tmpDist = dist2(path.points[path.points.length - 1], from);
                        if (tmpDist < minDist) {
                            minDist = tmpDist;
                            rev = true;
                            idx = i;
                        }
                    }
                }

                // use shape[idx] first
                const shape = shapes[idx];
                if (rev) {
                    for (let i = 0; i < shape.paths.length; i++) {
                        shape.paths[i].points = shape.paths[i].points.reverse();
                    }
                }
                from = shape.paths[shape.paths.length - 1].points[0];
                newShapes.push(shape);
                usedSet.add(idx);
            }

            return newShapes;
        }

        const { source, target, vectorMode } = this.options;

        const svgParser = new SVGParser();

        const svg = await svgParser.parseFile(source.processed);

        let minX = Infinity;
        let maxX = -Infinity;
        let minY = Infinity;
        let maxY = -Infinity;

        for (let shape of svg.shapes) {
            if (!shape.visibility) {
                continue;
            }
            for (let path of shape.paths) {
                for (let point of path.points) {
                    minX = Math.min(minX, point[0]);
                    maxX = Math.max(maxX, point[0]);
                    minY = Math.min(minY, point[1]);
                    maxY = Math.max(maxY, point[1]);
                }
            }
        }

        const normalizer = new Normalizer(target.anchor, minX, maxX, minY, maxY, {
            x: target.width / source.width,
            y: target.height / source.height
        });

        // second pass generate gcode
        let content = '';
        content += `G0 F${target.jogSpeed}\n`;
        content += `G1 F${target.workSpeed}\n`;

        const shapes = vectorMode.optimizePath ? sortBySeekTime(svg.shapes) : svg.shapes;
        for (let shape of shapes) {
            if (!shape.visibility) {
                continue;
            }
            for (let path of shape.paths) {
                for (let i = 0; i < path.points.length; i++) {
                    const point = path.points[i];
                    const x = point[0];
                    const y = minY + (maxY - point[1]);
                    if (i === 0) {
                        content += `G0 X${normalizer.x(x)} Y${normalizer.y(y)}\n`;
                        content += 'M3\n';
                    } else {
                        content += `G1 X${normalizer.x(x)} Y${normalizer.y(y)}\n`;
                        if (i + 1 === path.length) {
                            content += 'M5\n';
                        }
                    }
                }
            }
        }

        content += 'G0 X0 Y0\n';

        return content;
    }

    async generateGcodeText() {
        const { source, target } = this.options;

        const svgParser = new SVGParser();

        const svg = await svgParser.parseFile(source.image);

        let minX = Infinity;
        let maxX = -Infinity;
        let minY = Infinity;
        let maxY = -Infinity;

        for (let shape of svg.shapes) {
            for (let path of shape.paths) {
                for (let point of path.points) {
                    minX = Math.min(minX, point[0]);
                    maxX = Math.max(maxX, point[0]);
                    minY = Math.min(minY, point[1]);
                    maxY = Math.max(maxY, point[1]);
                }
            }
        }

        const normalizer = new Normalizer(target.anchor, minX, maxX, minY, maxY, {
            x: target.width / source.width,
            y: target.height / source.height
        });

        // second pass generate gcode
        let content = this.getGcodeHeader();
        content += `G0 F${target.jogSpeed}\n`;
        content += `G1 F${target.workSpeed}\n`;

        for (let shape of svg.shapes) {
            for (let path of shape.paths) {
                for (let i = 0; i < path.points.length; i++) {
                    const point = path.points[i];
                    const x = point[0];
                    const y = minY + (maxY - point[1]);
                    if (i === 0) {
                        content += `G0 X${normalizer.x(x)} Y${normalizer.y(y)}\n`;
                        content += 'M3\n';
                    } else {
                        content += `G1 X${normalizer.x(x)} Y${normalizer.y(y)}\n`;
                        if (i + 1 === path.length) {
                            content += 'M5\n';
                        }
                    }
                }
            }
        }

        content += 'G0 X0 Y0\n';
        return content;
    }
}

export default LaserToolPathGenerator;
